Principes SOLID utilisés : 
 - Single Responsible Principle (S.R.P) : permet à chaque fois de savoir quand créer une classe
 - Open Closed Principle (O.C.P) : permet de comprendre pourquoi sortir la liste des SPECIAL_CARDS de 'Card.js'
 - Depedency Inversion Principle (D.I.P) : permet de comprendre pourquoi injecter le Parser dans Game.js  

### 1. Tests dans Game

	Au bout du 2e test, je m'aperçois que j'ai besoin d'un parser donc je commente
	le 2e test et je créé un Parser

	it("should make white win with Ace card", () => {
		const result = game.play("Black: 2H 3D 5S 9C KD  White: 2C 3H 4S 8C AH");
		expect(result).toBe("White wins. - with high card: Ace");
	})

	// it("should make white win with Ace card", () => {
	// 	const result = game.play("Black: 2H 3D 5S 9C 9D  White: 2C 3H 4S 8C KH");
	// 	expect(result).toBe("White wins. - with high card: King");
	// })
		 
	
### 2. Tests dans Parser

	Je réecrit le test 3 fois pour y aller petit à petit : 
	- 1. Je chercher juste à séparer la main
	- 2. Je cherche juste à séparer les cartes de la main
	- 3. Je m'aperçois que j'ai besoin d'un objet Card
	je commente et je créé l'objet Card
	
	// it("should be defined after instanciation", () => {
	// 	const result = parser.parseHands("Black: 2H 3D 5S 9C KD  White: 2C 3H 4S 8C AH");
	// 	expect(result).toEqual({
	// 		"Black" : "2H 3D 5S 9C KD",
	// 		"White" : "2C 3H 4S 8C AH",
	// 	});
	// })
		

	it("should be defined after instanciation", () => {
		const result = parser.parseHands("Black: 2H 3D 5S 9C KD  White: 2C 3H 4S 8C AH");
		expect(result).toEqual({
			"Black" : ["2H", "3D", "5S", "9C", "KD"],
			"White" : ["2C", "3H", "4S", "8C", "AH"],
		});
	})


### 3. Tests dans Card

	Le premier test me donne la valeur, la couleur et le code par défaut
	les autres me donnent les cas particuliers

	it("should parse 3H code", () => {
		const card = new Card("3H");
		expect(card.value).toBe("3");
		expect(card.color).toBe("H");
		expect(card.name).toBe("3");
	})

	it("should parse Ten card", () => {
		const card = new Card("TH");
		expect(card.name).toBe("10");
	})

	it("should parse Jack card", () => {
		const card = new Card("JH");
		expect(card.name).toBe("Jack");
	})

	it("should parse Queen card", () => {
		const card = new Card("QH");
		expect(card.name).toBe("Queen");
	})

	it("should parse King card", () => {
		const card = new Card("KH");
		expect(card.name).toBe("King");
	})
		
	it("should parse Ace card", () => {
		const card = new Card("AH");
		expect(card.name).toBe("Ace");
	})
	
### 4. Tests parser 

	Je remonte dans le parser pour corriger le format et je suis prêt
	à retourner dans game	
	
	it("should parse hands", () => {
	const result = parser.parseHands("Black: 2H 3D 5S 9C KD  White: 2C 3H 4S 8C AH");
	expect(result).toEqual({
		"Black" : [new Card("2H"), new Card("3D"), new Card("5S"), new Card("9C"), new Card("KD")],
		"White" : [new Card("2C"), new Card("3H"), new Card("4S"), new Card("8C"), new Card("AH")],
	});
})

### 5. Tests Cards 

	En reprenant le Game.js est en tentant d'implémenter le High card 
	je m'aperçois que j'ai besoin d'un moyen pour comparer les cartes je retourne alors dans Cards
	
	Je décide après avoir écrit les tests d'utiliser un tableau de 
	SPECIAL_CARDS (SOLID) et de changer les noms de variabels pour avoir :
	- fullName (nom complet)
	- value (maintenant correspond à la valeur de compairaisons)
	- name = (shortname)

	je peux alors retourner dans le Game.js
	
	it("should tell than 3 is highest than 2", () => {
		const result = new Card("3H").isHighestThan(new Card("2H"));
		expect(result).toBe(true);
	})

	it("should tell than A is highest than 9", () => {
		const result = new Card("AH").isHighestThan(new Card("9H"));
		expect(result).toBe(true);
	})

	it("should tell than Q is lowest than K", () => {
		const result = new Card("QH").isHighestThan(new Card("KH"));
		expect(result).toBe(false);
	})
	
})

### 6. Tests Game 	

	J'arrive à mettre en place la règle du High card mais je m'aperçois que je vais avoir besoin
	d'un objet 'Hand' car j'ai du créer une méthode getHighestCard() dans Game qui semble plus adapté au niveau
	de Hand

	it("should make white win with Ace card High Card", () => {
		const result = game.play("Black: 2H 3D 5S 9C KD  White: 2C 3H 4S 8C AH");
		expect(result).toBe("White wins. - with high card: Ace");
	})

	it("should make white win with King card High Card", () => {
		const result = game.play("Black: 2H 3D 5S 9C 9D  White: 2C 3H 4S 8C KH");
		expect(result).toBe("White wins. - with high card: King");
	})

	it("should make black win with King card High Card", () => {
		const result = game.play("Black: 2H 3D 5S 9C KD  White: 2C 3H 4S 8C QH");
		expect(result).toBe("Black wins. - with high card: King");
	})

### 7. Hand Test 		

	1. Faire le test du highest card 
	2. Modifier Parser pour renvoyer une Hand
	3. utiliser la hand dans Game

	handTest :
	it("get highest card", () => {
		const hand = new Hand([new Card("KH"), new Card("QD"), new Card("5S"), new Card("9C"), new Card("2D")]);
		expect(hand.getHighestCard()).toEqual(new Card("KH"));
	})

	ParserTest : 
	it("should parse hands", () => {
		const result = parser.parseHands("Black: 2H 3D 5S 9C KD  White: 2C 3H 4S 8C AH");
		expect(result).toEqual({
			"Black" : new Hand([new Card("2H"), new Card("3D"), new Card("5S"), new Card("9C"), new Card("KD")]),
			"White" : new Hand([new Card("2C"), new Card("3H"), new Card("4S"), new Card("8C"), new Card("AH")]),
		});
	})

### 8. Pair detection

	1. j'écris le test dans Game et je m'aperçois que la Hand a besoin de me communiquer si il y a une paire
	Je commente et j'écrit le test dans Hand

	it("should detect Pair", () => {
		const hand = new Hand([new Card("KH"), new Card("KD"), new Card("5S"), new Card("9C"), new Card("2D")]);
		expect(hand.isPair()).toBe(true);
	})

### 9. Oops, mauvaise interpretation highestCard

	1. Je m'aperçois que j'ai mal compris le Tie du highest Card
	je décide alors de reprendre Hand et Game et de faire un tri des cartes
	pour évaluer une à une les cartes

	Je run régulierement 'npm test --coverage' pour éliminer le code mort

	HandTest : 
	it("should sort card from the highest to the lowest card", () => {
		const hand = new Hand([new Card("2D"), new Card("QD"), new Card("5S"), new Card("9C"), new Card("KH")]);
		expect(hand.sortCardByDsc()).toEqual([new Card("KH"), new Card("QD"), new Card("9C"), new Card("5S"), new Card("2D")]);
	})